## 音视频框架

### [FFmpeg](https://github.com/gongluck/3rdparty/tree/main/ffmpeg)

#### Linux编译

```shell
# 安装环境依赖
sudo apt-get update 
sudo apt-get -y install autoconf automake build-essential cmake git-core libass-dev libfreetype6-dev libsdl2-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev
# 安装依赖库
sudo apt-get -y install nasm yasm libx264-dev libx265-dev libnuma-dev libvpx-dev libfdk-aac-dev libmp3lame-dev libopus-dev
# 下载ffmpeg源码
wget https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2
# 编译
tar xjvf ffmpeg-snapshot.tar.bz2
cd ffmpeg
./configure --prefix="$PWD/ffmpeg_build" --pkg-config-flags="--static" --extra-cflags="-I$PWD/ffmpeg_build/include" --extra-ldflags="-L$PWD/ffmpeg_build/lib" --extra-libs="-lpthread -lm" --bindir="$PWD/ffmpeg_build/bin" --enable-gpl --enable-libass --enable-libfdk-aac --enable-libfreetype --enable-libmp3lame --enable-libopus --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libx265 --enable-nonfree
make -j 8
make install
```

#### Windows编译

```shell
# 安装MSYS2(Minimal SYStem 2)
# 把安装⽬录下的msys2_shell.cmd中注释掉的"rem set MSYS2_PATH_TYPE=inherit"改成启用，这是为了将vs的环境继承给MSYS2
# 编辑"/etc/pacman.d/mirrorlist.mingw32" 在⽂件开头添加：
Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/
Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686/
# 编辑"/etc/pacman.d/mirrorlist.mingw64" 在⽂件开头添加：
Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/
Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/
# 编辑"/etc/pacman.d/mirrorlist.msys" 在⽂件开头添加：
Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch/
Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch/
# 使用VS命令行运行msys2
msys2_shell.cmd -mingw64
# msys2中执行
pacman -Sy
pacman -S mingw-w64-x86_64-toolchain
pacman -S git
pacman -S make
pacman -S automake
pacman -S autoconf
pacman -S perl19
pacman -S libtool
pacman -S mingw-w64-i686-cmake
pacman -S pkg-config
pacman -S mingw-w64-x86_64-SDL2
# 重命名msys64/usr/bin/link.exe为msys64/usr/bin/link.bak
pacman -S yasm
pacman -S nasm
# 编译x264
git clone http://git.videolan.org/git/x264.git
cd x264
./configure --prefix=./build --host=x86_64-w64-mingw32 --enable-shared --enable-static --extra-ldflags=-Wl,--output-def=libx264.def
make -j 8
make install
cp ./libx264.def ./build/lib
cd ./build/lib
#lib /machine:i386 /def:libx264.def
lib /machine:X64 /def:libx264.def
# 编译fdk-aac
git clone --depth 1 https://gitee.com/mirrors/fdk-aac.git
cd fdk-aac
./autogen.sh
./configure --prefix=/e/Code/fdk-aac/build --enable-shared --enable-static
make -j 8
make install
# 编译mp3
git clone --depth 1 https://gitee.com/hqiu/lame.git
cd lame
./configure --prefix=/e/Code/lame/build --disable-shared --enable-static --disable-frontend
make -j 8
make install
# 编译libvpx
git clone --depth 1 https://github.com/webmproject/libvpx.git
cd libvpx
./configure --prefix=./build --disable-examples --disable-unit-tests --enable-vp9-highbitdepth --as=yasm
make -j 8
make install
# 编译ffmpeg
git clone git://source.ffmpeg.org/ffmpeg.git
cd ffmpeg
git checkout remotes/origin/release/4.2
./configure \
--prefix=./build \
--arch=x86_64 \
--enable-shared \
--enable-gpl \
--enable-libfdk-aac \
--enable-nonfree \
--enable-libvpx \
--enable-libx264 \
--enable-libmp3lame \
--extra-cflags="-I/e/Code/fdk-aac/build/include" \
--extra-ldflags="-L/e/Code/fdk-aac/build/lib" \
--extra-cflags="-I/e/Code/libvpx/build/include" \
--extra-ldflags="-L/e/Code/libvpx/build/lib" \
--extra-cflags="-I/e/Code/x264/build/include" \
--extra-ldflags="-L/e/Code/x264/build/lib" \
--extra-cflags="-I/e/Code/lame/build/include" \
--extra-ldflags="-L/e/Code/lame/build/lib"
make -j 8
make install
```

#### ffmpeg命令行

##### 查看帮助文档

```shell
ffmpeg -h
ffmpeg -h long
ffmpeg -h full

# 显示版本
ffmpeg -version
# 显示编译配置
ffmpeg -buildconf
# 显示可用格式（muxers+demuxers）
ffmpeg -formats
# 显示可用复用器
ffmpeg -muxers
# 显示可用解复用器
ffmpeg -demuxers
# 显示可用设备
ffmpeg -devices
# 显示可用编解码器（decoders+encoders）
ffmpeg -codecs
# 显示可用解码器
ffmpeg -decoders
# 显示可用编码器
ffmpeg -encoders
# 显示可用比特率过滤器
ffmpeg -bsfs
# 显示可用协议
ffmpeg -protocols
# 显示可用过滤器
ffmpeg -filters
# 显示可用过滤格式
ffmpeg -pix_fmts
# 显示可用声道布局
ffmpeg -layouts
# 显示可用音频采样格式
ffmpeg -sample_fmts
# 显示可用颜色
ffmpeg -colors

ffplay -h
ffprobe -h
```

##### ffmpeg命令

```shell
# 保留封装格式
ffmpeg -i test.mp4 -acodec copy -vn audio.mp4
ffmpeg -i test.mp4 -vcodec copy -an video.mp4

# 提取视频
#保留编码格式
ffmpeg -i test.mp4 -vcodec copy -an test_copy.h264
#强制格式
ffmpeg -i test.mp4 -vcodec libx264 -an test.h264

# 提取音频
#保留编码格式
ffmpeg -i test.mp4 -acodec copy -vn test.aac
#强制格式
ffmpeg -i test.mp4 -acodec libmp3lame -vn test.mp3

# 提取YUV
#提取3秒数据，分辨率和源视频一致
ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p yuv420p_orig.yuv
#提取3秒数据，分辨率转为320x240
ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p -s 320x240 yuv420p_320x240.yuv

# 提取RGB
#提取3秒数据，分辨率转为320x240
ffmpeg -i test.mp4 -t 3 -pix_fmt rgb24 -s 320x240 rgb24_320x240.rgb

# RGB和YUV之间的转换
ffmpeg -s 320x240 -pix_fmt yuv420p -i yuv420p_320x240.yuv -pix_fmt rgb24 rgb24_320x240_2.rgb

# 提取PCM
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f s16le 48000_2_s16le.pcm
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -sample_fmt s16 out_s16.wav
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -codec:a pcm_s16le out2_s16le.wav
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm
ffmpeg -i test.mp4 -t 10 -vn -ar 48000 -ac 2 -f f32le 48000_2_f32le_2.pcm

# 转封装
#保持编码格式
ffmpeg -i test.mp4 -vcodec copy -acodec copy test_copy.ts
ffmpeg -i test.mp4 -codec copy test_copy2.ts
#改变编码格式
ffmpeg -i test.mp4 -vcodec libx265 -acodec libmp3lame out_h265_mp3.mkv
#修改帧率
ffmpeg -i test.mp4 -r 15 output.mp4
#修改视频码率
ffmpeg -i test.mp4 -b:v 400k output_bv.mkv
#修改音频码率
ffmpeg -i test.mp4 -b:a 192k output_ba.mp4
#修改音视频码率
ffmpeg -i test.mp4 -b:v 400k -b:a 192k output_bva.mp4
#修改视频分辨率
ffmpeg -i test.mp4 -s 480x270 output_480x270.mp4
#修改音频采样率
ffmpeg -i test.mp4 -ar 44100 output_44100hz.mp3

# 推流
#h264推流
ffmpeg -re -i /mnt/e/Code/AnalysisAVP/media/gx.flv -vcodec h264 -acodec aac -f rtsp -rtsp_transport tcp rtsp://172.22.192.1/live/test
#h265推流
ffmpeg -re -i /mnt/e/Code/AnalysisAVP/media/gx.flv -vcodec hevc -acodec aac -f rtsp -rtsp_transport tcp rtsp://172.22.192.1/live/test
#copy
ffmpeg -re -i /mnt/e/Code/AnalysisAVP/media/gx.flv -vcodec copy -acodec copy -f flv -y rtmp://172.22.192.1/live/test
```

##### ffplay命令

```shell
# 播放YUV数据
ffplay -pixel_format yuv420p -video_size 320x240 -framerate 5 
yuv420p_320x240.yuv

# 播放RGB数据
ffplay -pixel_format rgb24 -video_size 320x240 -i rgb24_320x240.rgb
ffplay -pixel_format rgb24 -video_size 320x240 -framerate 5 -i rgb24_320x240.rgb

# 播放PCM数据
ffplay -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm
``` 

### [SDL2](https://github.com/gongluck/3rdparty/tree/main/SDL2)

![SDL架构](https://github.com/gongluck/images/blob/main/SDL架构.png)

#### Linux编译

```shell
./configure
make
sudo make install
#如果出现Could not initialize SDL - No available video device(Did you set the DISPLAY variable?)错误，说明系统中没有安装x11的库文件，因此编译出来的SDL库实际上不能用。下载安装
sudo apt-get install libx11-dev
sudo apt-get install xorg-dev
```

#### [SDL使用例子](./example/SDL2)

<details>
<summary>SDL使用例子</summary>

```C++
/*
 * @Author: gongluck 
 * @Date: 2021-01-23 14:12:40 
 * @Last Modified by:   gongluck 
 * @Last Modified time: 2021-01-23 14:12:40 
 */

#define SDL_MAIN_HANDLED

#include <iostream>
#include <fstream>
#include "SDL.h"

#define MY_QUIT		SDL_USEREVENT+1
#define MY_REFRESH	SDL_USEREVENT+2

const int WIDTH = 500;
const int HEIGHT = 300;
const int width = 10;
const int height = 10;

bool exitflag = false;

int mythread(void* param)
{
	while (!exitflag)
	{
		SDL_Event event;
		event.type = MY_REFRESH;
		SDL_PushEvent(&event);
		SDL_Delay(100);
	}

	SDL_Event event;
	event.type = MY_QUIT;
	SDL_PushEvent(&event);

	return 0;
}
void SDLCALL mypcm(void* userdata, Uint8* stream, int len)
{
	auto pcm = static_cast<std::iostream*>(userdata);
	auto buf = static_cast<char*>(malloc(len));
	pcm->read(buf, len);
	if (!pcm)
	{
		free(buf);
		return;
	}
	memcpy(stream, buf, len);
	free(buf);
}

//SDL2_example ../../../../media/gx_yuv420p_320x240.yuv 320 240 ../../../../media/gx_44100_2_s16le.pcm
int main(int argc, char* argv[])
{
	std::cout << "SDL2 demo" << std::endl;

	std::cout << "Usage : " << "thisfilename YUVfile width height PCMfile" << std::endl;

	if (argc < 5)
	{
		std::cerr << "please see the usage message." << std::endl;
		return -1;
	}
	std::ifstream yuv(argv[1], std::ios::binary);
	if (yuv.fail())
	{
		std::cerr << "can not open file " << argv[1] << std::endl;
		return -1;
	}
	auto yuvwidth = atoi(argv[2]);
	auto yuvheight = atoi(argv[3]);
	std::ifstream pcm(argv[4], std::ios::binary);
	if (pcm.fail())
	{
		std::cerr << "can not open file " << argv[4] << std::endl;
		return -1;
	}

	auto ret = SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
	SDL_Window* window = SDL_CreateWindow("SDL2", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WIDTH, HEIGHT, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);
	auto renderer = SDL_CreateRenderer(window, -1, 0);
	auto texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, WIDTH, HEIGHT);

	int i = 0;
	while (i++ < 20)
	{
		ret = SDL_SetRenderTarget(renderer, texture);
		ret = SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
		ret = SDL_RenderClear(renderer);
		SDL_Rect rect = { rand() % (WIDTH - width), rand() % (HEIGHT - height), width, height };
		ret = SDL_RenderDrawRect(renderer, &rect);
		ret = SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
		ret = SDL_RenderFillRect(renderer, &rect);

		ret = SDL_SetRenderTarget(renderer, nullptr);
		ret = SDL_RenderCopy(renderer, texture, nullptr, nullptr);

		SDL_RenderPresent(renderer);
		SDL_Delay(100);
	}

	auto yuvtexture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, yuvwidth, yuvheight);
	auto datasize = yuvwidth * yuvheight * 3 / 2;
	auto yuvdata = static_cast<char*>(malloc(datasize));
	auto th = SDL_CreateThread(mythread, nullptr, nullptr);

	SDL_AudioSpec spec = { 0 };
	spec.freq = 44100;
	spec.format = AUDIO_S16SYS;
	spec.channels = 2;
	spec.silence = 0;
	spec.samples = 1024;
	spec.callback = mypcm;
	spec.userdata = &pcm;
	ret = SDL_OpenAudio(&spec, nullptr);
	SDL_PauseAudio(0);

	SDL_Event event = { 0 };
	while (!exitflag)
	{
		ret = SDL_WaitEvent(&event);
		switch (event.type)
		{
		case SDL_KEYDOWN:
			if (event.key.keysym.sym >= SDLK_a && event.key.keysym.sym <= SDLK_z)
			{
				std::cout << char('a' + event.key.keysym.sym - SDLK_a) << " down" << std::endl;
			}
			else if (event.key.keysym.sym == SDLK_ESCAPE)
			{
				SDL_Event event_q;
				event_q.type = MY_QUIT;
				ret = SDL_PushEvent(&event_q);
				break;
			}
			break;
		case SDL_MOUSEBUTTONDOWN:
			if (event.button.button == SDL_BUTTON_LEFT)
			{
				std::cout << "mouse left down" << std::endl;
			}
			else if (event.button.button == SDL_BUTTON_RIGHT)
			{
				std::cout << "mouse right down" << std::endl;
			}
			else
			{
				std::cout << "mouse down" << std::endl;
			}
			break;
		case SDL_MOUSEMOTION:
			std::cout << "mouse move " << event.button.x << ", " << event.button.y << std::endl;
			break;
		case MY_REFRESH:
		{
			yuv.read(yuvdata, datasize);
			if (!yuv)
			{
				exitflag = true;
				break;
			}

			SDL_UpdateTexture(yuvtexture, nullptr, yuvdata, yuvwidth);
			SDL_RenderClear(renderer);
			//SDL_RenderCopy(renderer, yuvtexture, nullptr, nullptr);

			//旋转90°并且铺满渲染区域
			SDL_Point center = { yuvwidth, 0 };//src坐标系
			SDL_Rect  dstrect;//旋转后src坐标系
			dstrect.x = -yuvwidth;
			dstrect.y = 0;
			dstrect.w = yuvwidth;
			dstrect.h = yuvheight;
			SDL_RenderSetScale(renderer, (float)HEIGHT / dstrect.w, (float)WIDTH / dstrect.h);//按比例缩放
			SDL_RenderCopyEx(renderer, yuvtexture, nullptr, &dstrect, -90, &center, SDL_FLIP_NONE);

			SDL_RenderPresent(renderer);
		}
		break;
		case MY_QUIT:
			std::cout << "my quit envent." << std::endl;
			exitflag = true;
			break;
		}
	}

	SDL_WaitThread(th, nullptr);
	SDL_DestroyTexture(yuvtexture);
	SDL_DestroyTexture(texture);
	SDL_DestroyWindow(window);
	SDL_DestroyRenderer(renderer);

	SDL_PauseAudio(1);
	SDL_CloseAudio();

	SDL_Quit();

	yuv.close();
	free(yuvdata);
	pcm.close();

	return 0;
}

```
</details>

### SRS

- 编译SRS

  ```shell
  # SRS源码获取
  git clone https://gitee.com/winlinvip/srs.oschina.git srs
  cd srs/trunk
  git remote set-url origin https://github.com/ossrs/srs.git
  git pull
  git checkout 3.0release
  # 编译
  ./configure
  make -j 4
  # 运行
  ./objs/srs -c conf/srs.conf
  #./objs/srs -c conf/rtmp.conf
  #./objs/srs -c conf/hls.conf
  # 查看服务
  ps -ef | grep srs
  # 退出服务
  kill -SIGQUIT srspid
  ```

### ZLMediaKit

- 编译ZLMediaKit

  ```shell
  # 下载源码
  git clone --depth 1 https://gitee.com/xia-chu/ZLMediaKit
  cd ZLMediaKit
  # 千万不要忘记执行这句命令
  git submodule update --init
  # 安装依赖库
  sudo apt-get install libssl-dev -y
  sudo apt-get install libsdl-dev -y
  sudo apt-get install libavcodec-dev -y
  sudo apt-get install libavutil-dev -y
  sudo apt-get install ffmpeg -y
  # 编译
  mkdir build
  cd build
  cmake ..
  make -j 8
  # 运行
  cd ../release/linux/Debug
  #通过-h可以了解启动参数
  ./MediaServer -h
  #以守护进程模式启动
  sudo ./MediaServer -d &
  ```


### coturn

- 编译coturn

  ```shell
  # 安装依赖
  sudo apt-get install libssl-dev
  sudo apt-get install libevent-dev
  # 下载源码
  git clone https://github.com/coturn/coturn
  cd coturn
  # 编译安装
  ./configure prefix=/mnt/e/ubuntu/coturn/bin/
  make -j 8
  sudo make install
  # 启动
  turnserver --min-port 40000 --max-port 60000 -L 0.0.0.0 -a -u gongluck:123456 -v -f -r nort.gov
  # 浏览器测试
  https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/
  ```

### Nginx

- 编译nginx

    ```shell
    # 安装依赖
    sudo apt-get update
    sudo apt-get install build-essential libtool -y
    sudo apt-get install libpcre3 libpcre3-dev -y
    sudo apt-get install zlib1g-dev -y
    sudo apt-get install openssl -y
    #下载nginx
    wget http://nginx.org/download/nginx-1.19.0.tar.gz
    tar zxvf nginx-1.19.0.tar.gz
    cd nginx-1.19.0/
    # 配置，支持https
    ./configure --with-http_ssl_module
    # 编译
    make -j 8
    # 安装
    sudo make install
    # 启动
    sudo /usr/local/nginx/sbin/nginx
    # 停止
    sudo /usr/local/nginx/sbin/nginx -s stop
    # 重新加载配置文件
    sudo /usr/local/nginx/sbin/nginx -s reload
    ```
    
- 生成证书

    ```shell
    sudo mkdir -p /root/cert
    sudo cd /root/cert
    # CA私钥
    sudo openssl genrsa -out key.pem 2048
    # 自签名证书
    sudo openssl req -new -x509 -key key.pem -out cert.pem -days 1095
    ```

- 配置Web服务

    - 创建webrtc-­https.conf文件：

        ```shell
        server{
        	listen 443 ssl;
        	ssl_certificate /root/cert/cert.pem;
        	ssl_certificate_key /root/cert/key.pem;
        	charset utf‐8;
        	# ip地址或者域名
        	server_name www.gongluck.icu;
        	location / {
        		add_header 'Access-Control-Allow-Origin' '*';
        		add_header 'Access-Control-Allow-Credentials' 'true';
        		add_header 'Access-Control-Allow-Methods' '*';
        		add_header 'Access-Control-Allow-Headers' 'Origin, X-Requested-With, Content-Type,Accept';
        	# web页面所在目录
        	root /code/AnalysisAVP/example/WebRTC/demo/client/;
        	index index.php index.html index.htm;
        	}
        }
        ```

    - 创建webrtc-websocket-proxy.conf文件：

        ```shell
        map $http_upgrade $connection_upgrade {
        	default upgrade;
    	'' close;
        	}
    	upstream websocket {
        		server www.gongluck.icu:8099;
        	}
        	server {
        		listen 8098 ssl;
        		#ssl on;
        		ssl_certificate /root/cert/cert.pem;
        		ssl_certificate_key /root/cert/key.pem;
        		server_name www.gongluck.icu;
        	location /ws {
        		proxy_pass http://websocket;
        		proxy_http_version 1.1;
        		proxy_connect_timeout 4s; #配置点1
        		proxy_read_timeout 6000s; #配置点2，如果没效，可以考虑这个时间配置长一点
        		proxy_send_timeout 6000s; #配置点3
        		proxy_set_header Upgrade $http_upgrade;
        		proxy_set_header Connection $connection_upgrade;
        	}
        }
        ```
    
    - 编辑nginx.conf文件，在末尾}之前添加包含文件：
    
        ```shell
        include /code/AnalysisAVP/example/WebRTC/demo/client/webrtc-https.conf;
        include /code/AnalysisAVP/example/WebRTC/demo/client/webrtc-websocket-proxy.conf;
        ```
    

### nodejs

- 安装nodejs

  ```shell
  # 下载
  wget https://nodejs.org/dist/v15.0.0/node-v15.0.0-linux-x64.tar.xz
  # 解压
  tar -xvf node-v15.0.0-linux-x64.tar.xz
  # 进入目录
  cd node-v15.0.0-linux-x64
  # 执行软连接
  sudo ln ‐s /mnt/e/ubuntu/node-v15.0.0-linux-x64/bin/npm /usr/local/bin/
  sudo ln ‐s /mnt/e/ubuntu/node-v15.0.0-linux-x64/bin/node /usr/local/bin/
  ```
