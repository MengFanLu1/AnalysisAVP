## 流媒体协议

- [流媒体协议](#流媒体协议)
  - [RTMP](#rtmp)
  - [HLS](#hls)
  - [RTSP](#rtsp)
  - [WebSocket](#websocket)
  - [WebRTC](#webrtc)

### RTMP

#### RTMP简介

- **RTMP**(Real Time Messaging Protocol)是一个应用层协议，主要用于在**Flash player**和服务器之间传输视频、音频、控制命令等内容。该协议的突出优点是低延时。RTMP基于**TCP**，默认使用端口**1935**。

- **RTMP**协议是应⽤层协议，是要靠底层可靠的传输层协议（通常是**TCP**）来保证信息传输的可靠性的。在基于传输层协议的链接建⽴完成后，**RTMP**协议也要客户端和服务器通过“握⼿”来建⽴基于传输层链接之上的**RTMP Connection**链接，在Connection链接上会传输⼀些**控制信息**，如SetChunkSize,SetACKWindowSize。其中**CreateStream**命令会创建⼀个Stream链接，⽤于传输具体的⾳视频数据和控制这些信息传输的命令信息。**RTMP**协议传输时会对数据做⾃⼰的格式化，这种格式的消息我们称之为**RTMP Message**，⽽实际传输的时候为了更好地实现**多路复⽤、分包和信息的公平性**，发送端会把Message划分为**带有Message ID的Chunk**，每个Chunk可能是⼀个单独的Message，也可能是Message的⼀部分，在接收端会根据chunk中包含的data的⻓度，message id和message的⻓度把chunk还原成完整的Message，从⽽实现信息的收发。

#### RTMP播放基本流程

##### 握手

![RTMP握手](https://github.com/gongluck/images/blob/main/RTMP握手.png)

- 要建⽴⼀个有效的**RTMP Connection**链接，⾸先要“握⼿”。

- 客户端要向服务器发送**C0,C1,C2**（按序）三个chunk，服务器向客户端发送**S0,S1,S2**（按序）三个chunk，然后才能进⾏有效的信息传输。RTMP协议本身并没有规定这6个**Message**的具体传输顺序，但RTMP协议的实现者需要保证这⼏点：

  - 客户端要等收到S1之后才能发送C2
  - 客户端要等收到S2之后才能发送其他信息（控制信息和真实⾳视频等数据） 
  - 服务端要等到收到C0之后发送S1
  - 服务端必须等到收到C1之后才能发送S2
  - 服务端必须等到收到C2之后才能发送其他信息（控制信息和真实⾳视频等数据）

- 实际上，为了减少发送次数，一般是这样的：

  ![RTMP握手实际实现](https://github.com/gongluck/images/blob/main/RTMP握手实际实现.png)

  - Client -> Server：**C0+C1**
  - Server -> Client：**S0+S1+S2**
  - Client -> Server：**C2**

- **C0**和**S0**包都是一个单一的ܿ**8位字节**

  ![RTMP的C0和S0消息](https://github.com/gongluck/images/blob/main/RTMP的C0和S0消息.png)

  - 在**C0**中，这一字段指示出客户端要求的RTMP版本号。
  - 在**S0**中， 这一字段指示出服务器端选择的RTMP版本号。
  - **0、1、2**三个值是由早期݊其他产品使用的，是废弃值。
  - **3**为规范的版本。
  - **4-31**被保留为RTMP协议的未来实现版本使用。
  - **32-255**不允许使用 (来区分开**RTMP**和݊他常用一个可打印字符开始的文本协议)。
  - 无法识别客户端所要求版本号的服务器应该以版本**3**响应，(收到响应的) 客户端可以选择降低到版本**3**，或者放弃握手。
  
- **C1**和**S1**数据包的长度都是**1536**字节

  ![RTMP的C1和S1消息](https://github.com/gongluck/images/blob/main/RTMP的C1和S1消息.png)

  - **Time**(4个字节)，这个字段包含一个**timestamp**，用于本终端发送的所有后续块的时间起点。这个值可以是0，或者一些任意值。要同步多个块流，终端可以发送其他块流当前的**timestamp**的值。
  - **Zero**(4个字节)，这个字段必需都是0。
  - **Random data**(1528个字节)，这个字段可以包含任意值。终端需要区分出响应来自它发起的握手还是对端发起的握手，这个数据应该发送一些足够随机的数。这个不需要对随机数进行加密保护，也不需要动态值。

- **C2**和**S2**数据包的长度都是**1536**字节

  ![RTMP的C2和S2消息](https://github.com/gongluck/images/blob/main/RTMP的C2和S2消息.png)

  - **Time**(4个字节)，这个字段必须包含终端在**S1**(给**C2**)或者**C1**(给**S2**)发的**timestamp**。
  - **Time2**(4个字节)，这个字段必须包含终端先前发出数据包(**S1 **或者**C1**)**timestamp**。
  - **Random echo**(1528个字节)，这个字段必须包含终端发的**S1**(给**C2**)或者**S2**(给**C1**)的随机数。两端都可以一起使用**time**和**time2**字段再加当前**timestamp**快速估算带宽或者连接延迟，但这不太可能是有多大用处。

### HLS

- HLS简介

    - 作为Apple提出的⼀种基于HTTP的协议，HLS（HTTP Live Streaming）⽤于解决实时⾳视频流的传输。尤其是在移动端，由于iOS/H5不⽀持flash，使得HLS成了移动端实时视频流传输的⾸选。HLS经常⽤在直播领域，⼀些国内的直播云通常⽤HLS拉流（将视频流从服务器拉到客户端）。 HLS值得诟病之处就是其延迟严重，延迟通常在10-30s之间；

        ![HLS框架](./images/HLS框架.png)

- HLS协议

    ![HLS使用流程](./images/HLS使用流程.png)

    - 相对于常⻅的流媒体直播协议，例如RTMP协议、RTSP协议、MMS协议等，HLS直播最⼤的不同在于，直播客户端获取到的，并不是⼀个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时⻓的媒体⽂件（MPEG-TS格式），⽽客户端则不断的下载并播放这些⼩⽂件，因为服务器端总是会将最新的直播数据⽣成新的⼩⽂件，这样客户端只要不停的按顺序播放从服务器获取到的⽂件，就实现了直播。由此可⻅，基本上可以认为，HLS是以点播的技术⽅式来实现直播。由于数据通过HTTP协议传输，所以完全不⽤考虑防⽕墙或者代理的问题，⽽且分段⽂件的时⻓很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟⼀般总是会⾼于普通的流媒体直播协议；

    - HLS协议由三部分组成：HTTP、M3U8、TS。这三部分中，HTTP 是传输协议，M3U8 是索引⽂件，TS是⾳视频的媒体信息；

    - HLS的m3u8，是⼀个ts的列表，也就是告诉浏览器可以播放这些ts⽂件。有⼏个关键的参数，这些参数在 SRS 的配置⽂件中都有配置项：

        |        配置项         |                             作用                             |
        | :-------------------: | :----------------------------------------------------------: |
        |        #EXTM3U        |          每个M3U⽂件第⼀⾏必须是这个tag，起标示作⽤          |
        |    #EXT-X-VERSION     |        该属性可以没有，⽬前主要是version 3，最新的是7        |
        | #EXT-X-MEDIA-SEQUENCE | 每⼀个media URI在PlayList中只有唯⼀的序号，相邻之间序号+1，⼀个media URI并不是必须要包含的，如果没有，默认为0 |
        | #EXT-X-TARGETDURATION | 所有切⽚的最⼤时⻓。有些Apple设备这个参数不正确会⽆法播放。SRS会⾃动计算出 ts⽂件的最⼤时⻓，然后更新m3u8时会⾃动更新这个值。⽤户不必⾃⼰配置 |
        |        #EXTINF        | ts切⽚的实际时⻓，SRS提供配置项hls_fragment，但实际上的ts时⻓还受gop影响 |
        |     ts⽂件的数⽬      | SRS可配置hls_window（单位是秒，不是数量），指定m3u8中保存多少个切⽚。譬如，每个ts切⽚为10秒，窗⼝为60秒，那么m3u8中最多保存6个ts切⽚，SRS会⾃动清理旧的切⽚ |
        |    livestream-0.ts    | SRS会⾃动维护ts切⽚的⽂件名，在编码器重推之后，这个编号会继续增⻓，保证流的连续性。直到SRS重启，这个编号才重置为0 |

    - 每⼀个m3u8⽂件，分别对应若⼲个ts⽂件，这些ts⽂件才是真正存放视频的数据。m3u8⽂件只是存放了⼀些ts⽂件的配置信息和相关路径，当视频播放时，m3u8是动态改变的，video标签会解析这个⽂件，并找到对应的ts⽂件来播放，所以⼀般为了加快速度，m3u8放在web服务器上，ts⽂件放在cdn上；

- HLS协议优势

    - HLS相对于RTMP来讲使⽤了标准的HTTP协议来传输数据，可以避免在⼀些特殊的⽹络环境下被屏蔽；
    - HLS相⽐RTMP在服务器端做负载均衡要简单得多。因为HLS是基于⽆状态协议 HTTP实现的，客户端只需要按照顺序使⽤下载存储在服务器的普通ts⽂件进⾏播放就可以。⽽RTMP是⼀种有状态协议，很难对视频服务器进⾏平滑扩展，因为需要为每⼀个播放视频流的客户端维护状态；
    - HLS协议本身实现了码率⾃适应，在不同带宽情况下，设备可以⾃动切换到最适合⾃⼰码率的视频播放；

- HLS协议劣势

    - HLS协议在直播的视频延迟时间很难做到10s以下延时，⽽RTMP协议的延时可以降到1s左右；

- TS文件分层

    - ts⽂件为传输流⽂件，视频编码主要格式为 H264/MPEG4，⾳频为 AAC/MP3。ts⽂件分为三层：
        ![TS文件分层](./images/TS文件分层.png)
        - ts层：Transport Stream，是在pes层的基础上加⼊数据流的识别和传输必须的信息；
        - pes层： Packet Elemental Stream，是在⾳视频数据上加了时间戳等对数据帧的说明信息；
        - es层：Elementary Stream，即⾳视频数据；

    - ts包⼤⼩固定为188字节，ts层分为三个部分：ts header、adaptation field、payload；
    - ts header固定4个字节；adaptation field可能存在也可能不存在，主要作⽤是给不⾜188字节的数据做填充；payload是pes数据；

    - ts header:
        | name | size | desc |
        | :-: | :-: | :-: |
        | sync_byte | 8b | 同步字节，固定为0x47 |
        | transport_error_indicator | 1b | 传输错误指示符，表明在ts头的adapt域后由⼀个⽆⽤字节，通常都为0，这个字节算在adapt域⻓度内 |
        | payload_unit_start_indicator | 1b | 负载单元起始标示符，⼀个完整的数据包开始时标记为1 |
        | transport_priority | 1b | 传输优先级，0为低优先级，1为⾼优先级，通常取0 |
        | pid | 13b | pid值 |
        | transport_scrambling_control | 2b | 传输加扰控制，00表示未加密 |
        | adaptation_field_control | 2b | 是否包含⾃适应区，‘00’保留；‘01’为⽆⾃适应域，仅含有效负载；‘10’为仅含⾃适应域，⽆有效负载；‘11’为同时带有⾃适应域和有效负载 |
        | continuity_counter | 4b | 递增计数器，从0-f，起始值不⼀定取0，但必须是连续的 |

    - ts层的内容是通过PID值来标识的，主要内容包括：PAT表、PMT表、⾳频流、视频流。解析ts流要先找到PAT表，只要找到PAT就可以找到PMT，然后就可以找到⾳视频流了。PAT表和PMT表需要定期插⼊ts流，因为⽤户随时可能加⼊ts流，这个间隔⽐较⼩，通常每隔⼏个视频帧就要加⼊PAT和PMT。PAT和PMT表是必须的，还可以加⼊其它表如SDT（业务描述表）等，不过hls流只要有PAT和PMT就可以播放了；

    - PAT表：主要的作⽤就是指明了PMT表的PID值；
    - PMT表：主要的作⽤就是指明了⾳视频流的PID值；
    - ⾳频流/视频流：承载⾳视频内容；

    - adaptation field:
        | name | size | desc |
        | :-: | :-: | :-: |
        | adaptation_field_length | 1B | ⾃适应域⻓度，后⾯的字节数 |
        | flag | 1B | 取0x50表示包含PCR或0x40表示不包含PCR |
        | PCR | 5B | Program Clock Reference，节⽬时钟参考，⽤于恢复出与编码端⼀致的系统时序时钟STC（System Time Clock） |
        | stuffing_bytes | xB | 填充字节，取值0xff |

    - PAT:
        | name | size | desc |
        | :-: | :-: | :-: |
        | table_id | 8b | PAT表固定为0x00 |
        | section_syntax_indicator | 1b | 固定为14 |
        | zero | 1b | 固定为0 |
        | reserved | 2b | 固定为11 |
        | section_length | 12b | 后⾯数据的⻓度 |
        | transport_stream_id | 16b | 传输流ID，固定为0x0001 |
        | reserved | 2b | 固定为11 |
        | version_number | 5b | 版本号，固定为00000，如果PAT有变化则版本号加1 |
        | current_next_indicator | 1b| 固定为1，表示这个PAT表可以⽤，如果为0则要等待下⼀个PAT表 |
        | section_number | 8b | 固定为0x00 |
        | last_section_number | 8b | 固定为0x00 |
        | 开始循环 | | |
        | program_number | 16b | 节⽬号为0x0000时表示这是NIT，节⽬号为0x0001时,表示这是PMT |
        | reserved | 3b | 固定为111 |
        | PID | 13b | 节⽬号对应内容的PID值 |
        | 结束循环 | | |
        | CRC32 | 32b | 前⾯数据的CRC32校验码 |

    - PMT:
        | name | size | desc |
        | :-: | :-: | :-: |
        | table_id | 8b | PMT表取值随意，0x02 |
        | section_syntax_indicator | 1b | 固定为1 |
        | zero | 1b | 固定为0 |
        | reserved | 2b | 固定为11 |
        | section_length | 12b | 后⾯数据的⻓度 |
        | program_number | 16b | 频道号码，表示当前的PMT关联到的频道，取值0x0001 |
        | reserved | 2b | 固定为11 |
        | version_number | 5b | 版本号，固定为00000，如果PAT有变化则版本号加1 |
        | current_next_indicator | 1b | 固定为1 |
        | section_number | 8b | 固定为0x005 |
        | last_section_number | 8b | 固定为0x00 |
        | reserved | 3b | 固定为111 |
        | PCR_PID | 13b | PCR(节⽬参考时钟)所在TS分组的PID，指定为视频PID |
        | reserved | 4b | 固定为1111 |
        | program_info_length | 12b | 节⽬描述信息，指定为0x000表示没有 |
        | 开始循环 | | |
        | stream_type | 8b | 流类型，标志是Video还是Audio还是其他数据，h.264编码对应0x1b，aac编码对应0x0f，mp3编码对应0x03 |
        | reserved | 3b | 固定为111 |
        | elementary_PID | 13b | 与stream_type对应的PID |
        | reserved | 4b | 固定为1111 |
        | ES_info_length | 12b | 描述信息，指定为0x000表示没有 |
        | 结束循环 | | |
        | CRC32 | 32b | 前⾯数据的CRC32校验码 |

    - pes:
        | name | size | desc |
        | :-: | :-: | :-: |
        | pes start code | 3B | 开始码，固定为0x000001 |
        | stream id | 1B | ⾳频取值（0xc0-0xdf），通常为0xc0;视频取值（0xe0-0xef），通常为0xe0 |
        | pes packet length | 2B | 后⾯pes数据的⻓度，0表示⻓度不限制，只有视频数据⻓度会超过0xffff |
        | flag | 1B | 通常取值0x80，表示数据不加密、⽆优先级、备份的数据 |
        | flag | 1B | 取值0x80表示只含有pts，取值0xc0表示含有pts和dts |
        | pes data length | 1B | 后⾯数据的⻓度，取值5或10 |
        | pts | 5B | 33bit值 |
        | dts | 5B | 33bit值 |

### RTSP



### WebSocket

- WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议；

- WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输；

    ![Ajax和WebSocket](./images/Ajax和WebSocket.png)

- 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过TCP 连接直接交换数据；

- 当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过onmessage 事件来接收服务器返回的数据；

- 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息"Upgrade: WebSocket"表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接；

- 服务器端使用websocket需要安装nodejs-­websocket

    ```shell
    cd 工程目录
    sudo npm init
    #创建package.json文件
    sudo npm install nodejs-websocket
    ```

### WebRTC

- WebRTC简介

    - WebRTC（Web Real­Time Communication）是 Google于2010以6829万美元从 Global IP Solutions 公司购买，并于2011年将其开源，旨在建立一个互联网浏览器间的实时通信的平台，让 WebRTC技术成为 H5标准之一；
    - WebRTC虽然冠以“web”之名，但并不受限于传统互联网应用或浏览器的终端运行环境。实际上无论终端运行环境是浏览器、桌面应用、移动设备（Android或iOS）还是IoT设备，只要IP连接可到达且符合WebRTC规范就可以互通。这一点释放了大量智能终端（或运行在智能终端上的app）的实时通信能力，打开了许多对于实时交互性要求较高的应用场景的想象空间，譬如在线教育、视频会议、视频社交、远程协助、远程操控等等都是其合适的应用领域。全球领先的技术研究和咨询公司Technavio最近发布了题为“全球网络实时通讯（WebRTC）市场，2017­2021”的报告。报告显示，2017­2021年期间，全球网络实时通信（WebRTC）市场将以34.37％的年均复合增长率增长，增长十分迅速。增长主要来自北美、欧洲及亚太地区；

- WebRTC框架

    ![WebRTC架构](./images/WebRTC架构.png)

- WebRTC通话原理

    - 媒体协商

        - 有一个专门的协议，称为Session Description Protocol(SDP)，可用于描述上述这类信息，在WebRTC中，参与视频通讯的双方必须先交换SDP信息，这样双方才能知根知底，而交换SDP的过程，也称为"媒体协商"。

    - 网络协商

        ![WebRTC网络协商](./images/WebRTC网络协商.png)
        - 彼此要了解对方的网络情况，这样才有可能找到一条相互通讯的链路
        (1)获取外网IP地址映射；
        (2)通过信令服务器（signal server）交换"网络信息"。
        - 理想的网络情况是每个浏览器的电脑都是私有公网IP，可以直接进行点对点连接。
        - 实际情况是：我们的电脑和电脑之前或大或小都是在某个局域网中，需要NAT（Network Address Translation，网络地址转换）。
        - 在解决WebRTC使用过程中的上述问题的时候，我们需要用到STUN和TURN。

    - STUN

        - STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。

    - TURN
      
        - TURN的全称为Traversal Using Relays around NAT，是STUN/RFC5389的一个拓展，主要添加了Relay功能。如果终端在NAT之后，那么在特定的情景下，有可能使得终端无法和其对等端（peer）进行直接的通信，这时就需要公网的服务器作为一个中继，对来往的数据进行转发。这个转发的协议就被定义为TURN。

    - 信令服务器

        ![信令服务器](./images/信令服务器.png)

        - 在基于WebRTC API开发应用（APP）时，可以将彼此的APP连接到信令服务器（Signal Server，一般搭建在公网，或者两端都可以访问到的局域网），借助信令服务器，就可以实现上面提到的SDP媒体信息及Candidate网络信息交换。信令服务器不只是交互媒体信息sdp和网络信息candidate，不如房间管理和人员进出。

    - 一对一通话

        ![WebRTC一对一通话](./images/WebRTC一对一通话.png)
        
        - 在一对一通话场景中，每个 Peer均创建有一个 PeerConnection 对象，由一方主动发 Offer SDP，另一方则应答AnswerSDP，最后双方交换 ICE Candidate 从而完成通话链路的建立。但是在中国的网络环境中，据一些统计数据显示，至少1半的网络是无法直接穿透打通，这种情况下只能借助TURN服务器中转。

