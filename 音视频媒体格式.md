## 音视频媒体格式

### 视频主要概念

- **视频码率**：**kb/s**，是指视频文件在单位时间内使用的数据流量，也叫码流率。码率越大，说明单位时间内取样率越大，数据流精度就越高。
- **视频帧率**：**fps**，通常说一个视频的25帧，指的就是这个视频帧率，即1秒中会显示25帧。帧率越高，给人的视觉就越流畅。
- **视频分辨率**：分辨率就是我们常说的640x480分辨率、1920x1080分辨率，分辨率影响视频图像的大小。
- **I**帧（**Intra coded frames**）：
- I帧不需要参考其他画面而生成，解码时仅靠自己就重构完整图像；
  
- I帧图像采用帧内编码方式；
  
- I帧所占数据的信息量比较大；
  
- I帧图像是周期性出现在图像序列中的，出现频率可由编码器选择；
  
- I帧是P帧和B帧的参考帧（其质量直接影响到同组中以后各帧的质量）；
  
- **IDR**帧是帧组GOP的基础帧（第一个（I）帧），在一组GOP中只有一个IDR帧；
  
- I帧不需要考虑运动矢量；
- **P**帧（**Predicted frames**）根据本帧与相邻的前一帧（I帧或P帧）的不同点来压缩本帧数据，同时利用了空间和时间上的相关性。
- P帧属于前向预测的帧间编码。它需要参考前面最靠近它的**I**帧或**P**帧来解码。
- **B**帧（**Bi-directional predicted frames**）采用双向时间预测，可以大大提高压缩倍数。

### 音频主要概念

- **采样频率**：每秒钟采样的点的个数。常用的采样频率有：

    |      采样率      |   常见用途    |
    | :--------------: | :-----------: |
    |  22000（22kHz）  |   无线广播    |
    | 44100（44.1kHz） |    CD音质     |
    |  48000（48kHz）  | 数字电视，DVD |
    |  96000（96kHz）  | 蓝光，高清DVD |
    | 192000（192kHz） | 蓝光，高清DVD |

- **采样精度（采样深度）**：每个“样本点”的大小，常用的大小为8bit， 16bit，24bit。

- **通道数**：单声道，双声道，四声道，5.1声道。

- **比特率**：每秒传输的bit数，单位为：bps（Bit Per Second）。间接衡量声音质量的一个标准。没有压缩的音频数据的比特率 = 采样频率 * 采样精度 * 通道数。

- **码率**：压缩后的音频数据的比特率。常见的码率：

    |    码率     |   常见用途   |
    | :---------: | :----------: |
    |   96kbps    |    FM质量    |
    | 128-160kbps | 一般质量音频 |
    |   192kbps   |    CD质量    |
    | 256-320Kbps |  高质量音频  |

    - 码率越大，压缩效率越低，音质越好，压缩后数据越大。

    - 码率 = 音频文件大小 / 时长。

- **帧**：每次编码的采样单元数，比如MP3通常是1152个采样点作为一个编码单元，AAC通常是1024个采样点作为一个编码单元。

- **帧长**：可以指每帧播放持续的时间。每帧持续时间（秒）= 每帧采样点数 / 采样频率（HZ）。比如：MP3 48k，1152个采样点，每帧则为24毫秒，1152/48000 = 0.024秒 = 24毫秒；也可以指压缩后每帧的数据长度。

- **交错模式**：数字音频信号存储的方式。数据以连续帧的方式存放，即首先记录帧1的左声道样本和右声道样本，再开始帧2的记录...

- **非交错模式**：首先记录的是一个周期内所有帧的左声道样本，再记录所有右声道样本。

- 数字音频压缩编码在保证信号在听觉方面不产生失真的前提下，对音频数据信号进行尽可能大的压缩，降低数据量。数字音频压缩编码采取去除声音信号中冗余成分的方法来实现。所谓冗余成分指的是音频中不能被人耳感知到的信号，它们对确定声音的音色，音调等信息没有任何的帮助。

### 封装概念

- **封装格式**（也叫容器）就是将已经编码压缩好的视频流、音频流及字幕按照一定的方案放到一个文件中，便于播放软件播放。

- **一般来说，视频文件的后缀名就是它的封装格式。**

- **封装的格式不一样，后缀名也就不一样。**

### 音视频同步

- **DTS**（**Decoding Time Stamp**）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。

- **PTS**（**Presentation Time Stamp**）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。

- **音视频同步方式：**

    |         名称          |           实现           |
    | :-------------------: | :----------------------: |
    |     Audio Master      |      同步视频到音频      |
    |     Video Master      |      同步音频到视频      |
    | External Clock Master | 同步音频和视频到外部时钟 |

    - 一般情况下选择：Audio Master > External Clock Master > Video Master

### YUV格式

- 主要用于视频信号的压缩、传输和存储，和向后相容老式黑白电视。
- 其中**Y**表示明亮度（Luminance或Luma），**也称灰阶值**。
- **U**和**V**表示的则是色度（Chrominance或Chroma），作用是描述影像**色彩**及**饱和度**，用于指定像素的颜色。
- 对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。
- 对于packed的YUV格式，每个像素点的Y，U，V是连续存储的。
- **libyuv**，Google开源的实现各种YUV与RGB间相互转换、旋转、缩放的高效库。
- YUV4:4:4采样，每一个Y对应一组UV分量。
- YUV4:2:2采样，每两个Y共用一组UV分量。 
- YUV4:2:0采样，每四个Y共用一组UV分量。

### H264（新一代视频压缩编码标准）

- H264采⽤了16*16的分块⼤⼩对视频帧图像进⾏相似⽐较和压缩编码。

- H264使⽤帧内压缩和帧间压缩的⽅式提⾼编码压缩率。

- H264采⽤了独特的I帧、P帧和B帧策略来实现连续帧之间的压缩。

    ![h264层次](./images/h264层次.png)

- H264将视频分为连续的帧进⾏传输，在连续的帧之间使⽤I帧、P帧和B帧。同时对于帧内⽽⾔，将图像分为⽚、宏块和子块进⾏传输；通过这个过程实现对视频⽂件的压缩包装。

- ⼀个序列的第⼀个图像叫做IDR图像（⽴即刷新图像），IDR图像都是I帧图像。I帧和IDR帧都使⽤帧内预测。I帧不⽤参考任何帧，但是之后的P帧和B帧是有可能参考这个I帧之前的帧的。IDR就不允许这样，其核⼼作⽤是为了解码的重同步，当解码器解码到IDR图像时，⽴即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始⼀个新的序列。这样，如果前⼀个序列出现重⼤错误，在这⾥可以获得重新同步的机会。IDR图像之后的图像永远不会使⽤IDR之前的图像的数据来解码。

    ![gop](./images/gop.png)

- SPS：序列参数集。SPS中保存了⼀组**编码视频序列（Coded video sequence）**的全局参数。

- PPS：图像参数集。对应的是⼀个序列中某⼀幅图像或者某⼏幅图像的参数。

- I帧：帧内编码帧，可独⽴解码⽣成完整的图⽚。

- P帧： 前向预测编码帧，需要参考其前⾯的⼀个I帧或者B帧来⽣成⼀张完整的图⽚。

- B帧：双向预测内插编码帧，则要参考其前⼀个I或者P帧及其后⾯的⼀个P帧来⽣成⼀张完整的图⽚。  

- 发I帧之前，⾄少要发⼀次SPS和PPS。 

    ![H.264码流分层结构](./images/H.264码流分层结构.png)

- NAL层，视频数据网络抽象层（Network Abstraction Layer）

- VCL层，视频数据编码层（Video Coding Layer）

    ![RBSP与SODB](./images/RBSP与SODB.png)

- SODB，数据位串（String Of Data Bits）。原始数据比特流，长度不一定是8的倍数，故需要补齐。由VCL层产生。

- RBSP，原始字节序列负载（Raw Byte Sequence Playload）。SODB + trailing bits，算法是如果SODB最后一个字节不对齐，则补1和多个0。

    ![NALU](./images/NALU.png)

    ![NAL_Header](./images/NAL_Header.png)

- NALU，NAL单元。NAL Header（1B）+ RBSP。

- H.264标准指出，当数据流是储存在介质上时，在每个NALU前添加起始码0x000001或0x00000001，⽤来指示⼀个NALU的起始和终⽌位置 。

- 3字节的0x000001只有⼀种场合下使⽤，就是⼀个完整的帧被编为多个slice（⽚）的时候，包含这些slice的NALU使⽤3字节起始码。其余场合都是4字节0x00000001的。  

- H264有两种封装
    - ⼀种是annexb模式，传统模式，有startcode，SPS和PPS是在ES中。
    - ⼀种是mp4模式，⼀般mp4 mkv都是mp4模式，没有startcode，SPS和PPS以及其它信息被封装在container中，每⼀个frame前⾯4个字节是这个frame的⻓度。很多解码器只⽀持annexb这种模式，因此需要将mp4做转换。在ffmpeg中⽤h264_mp4toannexb_filter可以做转换。
    
- 通过提⾼GOP值来提⾼图像质量是有限度的，在遇到场景切换的情况时，H.264编码器会⾃动强制插⼊⼀个I帧，此时实际的GOP值被缩短了。另⼀⽅⾯，在⼀个GOP中，P、B帧是由I帧预测得到的，当I帧的图像质量⽐较差时，会影响到⼀个GOP中后续P、B帧的图像质量，直到下⼀个GOP开始才有可能得以恢复，所以GOP值也不宜设置过⼤。  

- 由于P、B帧的复杂度⼤于I帧，所以过多的P、B帧会影响编码效率，使编码效率降低。另外，过⻓的GOP还会影响seek操作的响应速度，由于P、B帧是由前⾯的I或P帧预测得到的，所以seek操作需要直接定位，解码某⼀个P或B帧时，需要先解码得到本GOP内的I帧及之前的N个预测帧才可以。GOP值越⻓，需要解码的预测帧就越多，seek响应的时间也越⻓。  

- P帧特点：
    1) P帧是I帧后⾯相隔1~2帧的编码帧；
    2) P帧采⽤运动补偿的⽅法传送它与前⾯的I或P帧的差值及运动⽮量（预测误差）；
    3) 解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像；
    4) P帧属于前向预测的帧间编码。它只参考前⾯最靠近它的I帧或P帧；
    5) P帧可以是其后⾯P帧的参考帧，也可以是其前后的B帧的参考帧；
    6) **由于P帧是参考帧，它可能造成解码错误的扩散；**
    7) 由于是差值传送，P帧的压缩⽐较⾼。  
    
- B帧特点：
    1）B帧是由前⾯的I或P帧和后⾯的P帧来进⾏预测的；
    2）B帧传送的是它与前⾯的I或P帧和后⾯的P帧之间的预测误差及运动⽮量；
    3）B帧是双向预测编码帧；
    4）B帧压缩⽐最⾼，因为它只反映两参考帧间运动主体的变化情况，预测⽐较准确；
    5）**B帧不是参考帧，不会造成解码错误的扩散。**
    
- H264分析代码：[H264分析代码](./analysis/h264/)

### AAC（高级音频编码）

- **ADIF**，音频数据交换格式（Audio Data Interchange Format）。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。

- **ADTS**，音频数据传输流（Audio Data Transport Stream）。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于**mp3**数据流格式。

    ![ADTS帧](https://github.com/gongluck/images/blob/main/ADTS帧.png)

    - 每⼀帧的**ADTS**的头⽂件都包含了⾳频的采样率，声道，帧⻓度等信息，这样解码器才能解析读取。⼀般情况下**ADTS**的头信息都是7个字节，分为2部分：

        - adts_fixed_header()；

        - adts_variable_header()；

        - 其⼀为固定头信息，紧接着是可变头信息。固定头信息中的数据每⼀帧都相同，⽽可变头信息则在帧与帧之间可变。

    - syncword：同步头，总是**0xFFF**，**all bits must be 1**，代表着⼀个**ADTS**帧的开始。

    - ID：MPEG标识符，0标识**MPEG-4**，1标识**MPEG-2**。
    
    - Layer：always: '00'。
    
    - protection_absent：表示是否误码校验。**Warning, set to 1 if there is no CRC and 0 if there is CRC**。
    
    - profile：表示使⽤哪个级别的**AAC**，如01 Low Complexity(LC)--- AAC LC。有些芯⽚只⽀持**AAC LC**。profile的值等于**Audio Object Type的值减1**。**profile = MPEG-4 Audio Object Type - 1**。
    
    - sampling_frequency_index：表示使⽤的采样率下标，通过这个下标在**Sampling Frequencies[ ]数组**中查找得知采样率的值。
    
    - channel_configuration：表示声道数，⽐如2表示⽴体声双声道。
    
    - frame_length：⼀个**ADTS**帧的⻓度包括**ADTS头和AAC原始流**：
        - frame length, this value must include 7 or 9 bytes of header length；
        - aac_frame_length = (protection_absent == 1 ? 7 : 9) + size(AACFrame)；
        - protection_absent=0时，header length=9bytes；
        - protection_absent=1时，header length=7bytes；
    - adts_buffer_fullness：**0x7FF**说明是**码率可变**的码流。
    - number_of_raw_data_blocks_in_frame：表示**ADTS**帧中有number_of_raw_data_blocks_in_frame + 1个**AAC**原始帧。所以说number_of_raw_data_blocks_in_frame == 0表示说**ADTS**帧中只有⼀个**AAC**数据块。
    
- **ADTS**可以在任意帧解码，也就是说它每⼀帧都有头信息。**ADIF**只有⼀个统⼀的头，所以必须得到所有的数据后解码。

- [AAC分析代码](./analysis/aac/)

    <details>
    <summary>AAC分析代码</summary>

    ```C++
    /*
     * @Author: gongluck 
     * @Date: 2020-11-02 23:11:22 
     * @Last Modified by: gongluck
     * @Last Modified time: 2021-05-09 17:51:35
     */
    
    #pragma once
    
    //Advanced Audio Coding(⾼级⾳频编码)
    
    #include <stdint.h>
    #include <iostream>
    
    //ADTS ID
    #define ADTS_ID_MPEG4 0 //标识MPEG-4
    #define ADTS_ID_MPEG2 1 //标识MPEG-2
    
    //ADTS profile
    #define ADTS_PROFILE_MAIN 0			  //Main profile
    #define ADTS_PROFILE_LC 1			  //Low Complexity Profile(LC)
    #define ADTS_PROFILE_SSR 2			  //Scalable Sampling Rate profile(SSR)
    #define ADTS_PROFILE_LTP 3			  //AAC LTP
    #define ADTS_PROFILE_SBR 4			  //SBR
    #define ADTS_PROFILE_AACSCALABLE 5	  //AAC scalable
    #define ADTS_PROFILE_TWINVQ 6		  //TwinVQ
    #define ADTS_PROFILE_CELP 7			  //CELP
    #define ADTS_PROFILE_HVXC 8			  //HVXC
    									  //9..10	//(reserved)
    #define ADTS_PROFILE_TTSI 11		  //TTSI
    #define ADTS_PROFILE_MAINSYNTHETIC 12 //Main synthetic
    #define ADTS_PROFILE_WAVESYNTHETIC 13 //Wavetable synthesis
    #define ADTS_PROFILE_GENERALMIDI 14	  //General MIDI
    #define ADTS_PROFILE_ALGORITHMICFX 15 //Algorithmic Synthesis and Audio FX
    #define ADTS_PROFILE_FRAACLC 16		  //FR AAC LC
    
    //ADTS sampling frequencies
    const int SamplingFrequencies[16] = {
    	96000,
    	88200,
    	64000,
    	48000,
    	44100,
    	32000,
    	24000,
    	22050,
    	16000,
    	12000,
    	11025,
    	8000,
    	7350,
    	-1 /*reserved*/,
    	-1 /*reserved*/,
    	-1 /*escape value*/,
    };
    
    //ADTS channel configuration
    #define ADTS_CHANNEL_CONFIGURATION_AOT 0				   //Defined in AOT Specifc Config
    #define ADTS_CHANNEL_CONFIGURATION_SINGLE 1				   //1 channel : front - center
    #define ADTS_CHANNEL_CONFIGURATION_PAIR 2				   //2 channels : front - left, front - right
    #define ADTS_CHANNEL_CONFIGURATION_SINGLEPAIR 3			   //channels : front - center, front - left, front - right
    #define ADTS_CHANNEL_CONFIGURATION_SINGLEPAIRSINGLE 4	   //channels : front - center, front - left, front - right, back - center
    #define ADTS_CHANNEL_CONFIGURATION_SINGLEPAIRPAIR 5		   //channels : front - center, front - left, front - right, back - left, backright
    #define ADTS_CHANNEL_CONFIGURATION_SINGLEPAIRPAIRLEF 6	   //channels : front - center, front - left, front - right, back - left, backright, LFE - channel
    #define ADTS_CHANNEL_CONFIGURATION_SINGLEPAIRPAIRPAIRLEF 8 //channels : front - center, front - left, front - right, side - left, side - right, back - left, back - right, LFE - channel
    														   //8..15	//Reserved
    
    typedef struct __ADTS
    {
    	//16bit
    	uint8_t syncwordL : 8;		   //同步头低8位 总是0xFF, all bits must be 1，代表着⼀个ADTS帧的开始
    	uint8_t protection_absent : 1; //表示是否误码校验。Warning, set to 1 if there is no CRC and 0 if there is CRC
    	uint8_t layer : 2;			   //always: '00'
    	uint8_t ID : 1;				   //MPEG标识符，ADTS_ID_XXX
    	uint8_t syncwordH : 4;		   //同步头高4位 总是0xF, all bits must be 1，代表着⼀个ADTS帧的开始
    
    	//8bit
    	uint8_t channel_configurationH : 1; //表示声道数高1位
    	uint8_t private_bit : 1;
    	uint8_t sampling_frequency_index : 4; //表示使⽤的采样率下标，通过这个下标在SamplingFrequencies[]数组中查找得知采样率的值
    	uint8_t profile : 2;				  //表示使⽤哪个级别的AAC，ADTS_PROFILE_XXX。有些芯⽚只⽀持AAC LC。
    
    	//8bit
    	uint8_t aac_frame_lengthH : 2;
    	uint8_t copyright_identification_start : 1;
    	uint8_t copyright_identification_bit : 1;
    	uint8_t home : 1;
    	uint8_t original_copy : 1;
    	uint8_t channel_configurationL : 2; //表示声道数低2位
    
    	//24bit
    	uint8_t aac_frame_lengthM : 8;
    	uint8_t adts_buffer_fullnessH : 5;
    	uint8_t aac_frame_lengthL : 3;		   //⼀个ADTS帧的⻓度包括ADTS头和AAC原始流.
    										   //frame length, this value must include 7 or 9 bytes of header length :
    										   //aac_frame_length = (protection_absent == 1 ? 7 : 9) + size(AACFrame)
    										   //protection_absent = 0时, header length = 9bytes
    										   //protection_absent = 1时, header length = 7bytes
    	uint8_t number_of_raw_data_blocks : 2; //表示ADTS帧中有number_of_raw_data_blocks_in_frame + 1个AAC原始帧。
    										   //所以说number_of_raw_data_blocks_in_frame == 0 表示说ADTS帧中有⼀个AAC数据块。
    	uint8_t adts_buffer_fullnessL : 6;	   //0x7FF 说明是码率可变的码流。
    } ADTS;
    
    uint16_t get_syncword(const ADTS &adts);
    void set_syncword(ADTS &adts, uint16_t syncword);
    uint8_t get_channel_configuration(const ADTS &adts);
    void set_channel_configuration(ADTS &adts, uint8_t channel_configuration);
    uint16_t get_aac_frame_length(const ADTS &adts);
    void set_aac_frame_length(ADTS &adts, uint16_t aac_frame_length);
    uint16_t get_adts_buffer_fullness(const ADTS &adts);
    void set_adts_buffer_fullness(ADTS &adts, uint16_t adts_buffer_fullness);
    
    const char *adts_parse_id(uint8_t id);
    const char *adts_parse_profile(uint8_t profile);
    const char *adts_parse_channelconfiguration(uint8_t channelconfiguration);
    
    std::ostream &operator<<(std::ostream &os, const ADTS &adts);
    
    ```
    </details>

### FLV（Flash Video）

![flv文件结构](./images/flv文件结构.png)

![flv详细文件结构](./images/flv详细文件结构.png)

- FLV（Flash Video）是Adobe公司推出的⼀种流媒体格式，由于其封装后的⾳视频⽂件体积⼩、封装简单等特点，⾮常适合于互联⽹上使⽤。⽬前主流的视频⽹站基本都⽀持FLV。  

- FLV封装格式是由⼀个⽂件头和⽂件体组成。其中，FLV body由⼀对对的（Previous Tag Size字段 + tag）组成。Previous Tag Size字段排列在Tag之前，占⽤4个字节。Previous Tag Size记录了前⾯⼀个Tag的⼤⼩，⽤于逆向读取处理。FLV header后的第⼀个Pervious Tag Size的值为0。

- FLV header由如下字段组成，其中前三个字节内容固定是*FLV*，最后4个字节内容固定是9（对*FLV*版本1来说）：

    | 字段 | 字段类型 | 字段含义 |
    | :- | :--: | :- |
    | Signature | UI8 |签名，固定为'F' (0x46)|
    | Signature | UI8 |签名，固定为'L' (0x4c)|
    | Signature | UI8 |签名，固定为'V' (0x56)|
    | Version | UI8 |版本，比如 0x01 表示 FLV 版本 1|
    | TypeFlagsReserved | UB[5] |全为0|
    | TypeFlagsAudio | UB[1] |1表示有audio tag，0表示没有|
    | TypeFlagsReserved | UB[1] |全为0|
    | TypeFlagsVideo | UB[1] |1表示有video tag，0表示没有|
    | DataOffset | UI32 |FLV header的大小，单位是字节|

- FLV file body很有规律，由一系列的*TagSize*和*Tag*组成，其中*PreviousTagSize0*总是为0；*tag*由*tag header*、*tag body*组成；对*FLV*版本1，*tag header*固定为11个字节。因此，*PreviousTagSize*（除第1个）的值为 11 + 前一个*tag*的*tag body*的大小：

    | 字段 | 字段类型 | 字段含义 |
    | :- | :-: | :- |
    | PreviousTagSize0 | UI32 |总是0|
    | Tag1 | FLVTAG |第1个tag|
    | PreviousTagSize1 | UI32 |前一个tag的大小，包括tag header|
    | Tag2 | FLVTAG |第2个tag|
    | ... | ... |...|
    | PreviousTagSizeN-1 | UI32 |第N-1个tag的大小|
    | TagN | FLVTAG |第N个tag|
    | PreviousTagSizeN | UI32 |第N个tag的大小，包含tag header|

- FLV tag由*tag header*+*tag body*组成。*tag header*如下，总共占据11个字节：
  
| 字段 | 字段类型 |字段含义|
| :- | :-: | :- |
| TagType | UI8 |tag类型：<br>8：audio<br>9：video<br>18：script data<br>其他：保留 |
| DataSize | UI24 |tag body的大小|
| Timestamp | UI24 |相对于第一个tag的时间戳（单位是毫秒）第一个tag的Timestamp为0|
| TimestampExtended | UI8 |时间戳的扩展字段，当 Timestamp 3个字节不够时，会启用这个字段，代表高8位|
| StreamID | UI24 |总是0|
| Data | 取决于根据TagType |TagType=8，则为AUDIODATA<br>TagType=9，则为VIDEODATA<br>TagType=18，则为SCRIPTDATAOBJECT|

- Tag⼀般可以分为3种类型：脚本(帧)数据类型、⾳频数据类型、视频数据。FLV数据以⼤端序进⾏存储，在解析时需要注意。

    ![flv解析过程](./images/flv解析过程.png)

- ⼀个FLV⽂件，每种类型的tag都属于⼀个流，也就是⼀个flv⽂件最多只有⼀个⾳频流，⼀个视频流，不存在多个独⽴的⾳视频流在⼀个⽂件的情况。

- flv⽂件中Timestamp和TimestampExtended拼出来的是dts。也就是解码时间。Timestamp和TimestampExtended拼出来dts单位为ms。（如果不存在B帧，当然dts等于pts）。

- Script data脚本数据就是描述视频或⾳频的信息的数据，如宽度、⾼度、时间等等，⼀个⽂件中通常只有⼀个元数据，⾳频tag和视频tag就是⾳视频信息了，采样、声道、频率，编码等信息。 

- **Script Tag Data结构（脚本类型、帧类型）**

    ![amf](./images/amf.png)

    - 该类型Tag⼜被称为MetaData Tag，存放⼀些关于FLV视频和⾳频的元信息，⽐如：duration、width、height等。通常该类型Tag会作为FLV⽂件的第⼀个tag，并且只有⼀个，跟在File Header后。

    - AMF包中第一个字节为类型标识：

        |        类型        |  值  |
        | :----------------: | :--: |
        |       Number       | 0x00 |
        |      Boolean       | 0x01 |
        |       String       | 0x02 |
        |       Object       | 0x03 |
        |     MovieClip      | 0x04 |
        |        Null        | 0x05 |
        |     Undefined      | 0x06 |
        |     Reference      | 0x07 |
        |     ECMAArray      | 0x08 |
        |     ObjectEnd      | 0x09 |
        |    StrictArray     | 0x0a |
        |        Date        | 0x0b |
        |     LongString     | 0x0c |
        |    Unsupported     | 0x0d |
        |     Recordset      | 0x0e |
        |     XMLObject      | 0x0f |
        | TypedObject(Class) | 0×10 |

* **Audio Tag Data结构（⾳频类型）**

    - *Audio tags*定义如下所示：

        | 字段 | 字段类型 |字段含义|
        | :- | :-: | :- |
        | SoundFormat | UB[4] |音频格式，重点关注 10 = AAC<br>0 = Linear PCM, platform endian<br>1 = ADPCM<br>2 = MP3<br>3 = Linear PCM, little endian<br>4 = Nellymoser 16-kHz mono<br>5 = Nellymoser 8-kHz mono<br>6 = Nellymoser<br>7 = G.711 A-law logarithmic PCM<br>8 = G.711 mu-law logarithmic PCM<br>9 = reserved<br>10 = AAC<br>11 = Speex<br>14 = MP3 8-Khz<br>15 = Device-specific sound|
        | SoundRate | UB[2] |采样率，对AAC来说，永远等于3<br>0 = 5.5-kHz<br>1 = 11-kHz<br>2 = 22-kHz<br>3 = 44-kHz|
        | SoundSize | UB[1] |采样精度，对于压缩过的音频，永远是16位<br>0 = snd8Bit<br>1 = snd16Bit|
        | SoundType | UB[1] |声道类型，对Nellymoser来说，永远是单声道；对AAC来说，永远是双声道；<br>0 = sndMono 单声道<br>1 = sndStereo 双声道|
        | SoundData | UI8[size of sound data] |如果是AAC，则为AACAUDIODATA；其他请参考规范。|
    
        - *AACAUDIODATA*

            当*SoundFormat*为10时，表示音频采AAC进行编码，此时，*SoundData*的定义如下：
    
            | 字段 | 字段类型 | 字段含义|
            | :- | :-: | :- |
            | AACPacketType | UI8 |0: AAC sequence header<br>1: AAC raw|
            | Data | UI8[n] |如果AACPacketType为0，则为AudioSpecificConfig；如果AACPacketType为1，则为AAC帧数据。|
    
        - *AudioSpecificConfig*
    
            | 字段 | 字段类型 | 字段含义 |
            | :- | :-: | :- |
            | AudioObjectType | UB[5] |编码器类型，比如2表示AAC-LC。|
            | SamplingFrequencyIndex | UB[4] | 采样率索引值，比如4表示44100。 |
            | ChannelConfiguration | UB[4] | 声道配置，比如2代表双声道，front-left，front-right。 |
            | AOT Specific Config | UB[n] ||
    
    - ⾳频Tag Data区域开始的第⼀个字节包含了⾳频数据的参数信息，第⼆个字节开始为⾳频流数据。（这两个字节属于tag的data部分，不是header部分）。第⼆个字节开始为⾳频数据（需要判断该数据是真正的⾳频数据，还是⾳频config信息）。
    
        ![aac audio data](./images/aac_audio_data.png)
    
- **Video Tag Data结构（视频类型）** 

    - *Video tags*定义如下：

        | 字段 | 字段类型 | 字段含义 |
        | :- | :-: | :- |
        | FrameType | UB[4] |重点关注1、2：<br>1: keyframe (for AVC, a seekable frame) —— 即H.264的IDR帧；<br>2: inter frame (for AVC, a non- seekable frame) —— H.264的普通I帧；<br>3: disposable inter frame (H.263 only)<br>4: generated keyframe (reserved for server use only)<br>5: video info/command frame|
        | CodecID | UB[4] |编解码器，主要关注 7（AVC）<br>1: JPEG (currently unused)<br>2: Sorenson H.263<br>3: Screen video<br>4: On2 VP6<br>5: On2 VP6 with alpha channel<br>6: Screen video version 2<br>7: AVC|
        | VideoData | 取决于CodecID |实际的媒体类型，主要关注 7:AVCVIDEOPACKE<br>2: H263VIDEOPACKET<br>3: SCREENVIDEOPACKET<br>4: VP6FLVVIDEOPACKET<br>5: VP6FLVALPHAVIDEOPACKET<br>6: SCREENV2VIDEOPACKET<br>7: AVCVIDEOPACKE|

        - *AVCVIDEOPACKE*当*CodecID*为7时，*VideoData*为 *AVCVIDEOPACKE*，也即*H.264*媒体数据。
        *AVCVIDEOPACKE*的定义如下：

        | 字段 | 字段类型 | 字段含义 |
        | :- | :-: | :- |
        | AVCPacketType | UI8 | 0: AVC sequence header<br>1: AVC NALU<br>2: AVC end of sequence |
        | CompositionTime | SI24 | 如果AVCPacketType=1，则为时间cts偏移量；否则，为0。当B帧的存在时，视频解码呈现过程中，dts、pts可能不同，cts的计算公式为 pts - dts/90，单位为毫秒；如果B帧不存在，则cts固定为0。 |
        | Data | UI8[n] | 1、如果如果AVCPacketType=0，则为AVCDecoderConfigurationRecord，H.264 视频解码所需要的参数集（SPS、PPS）<br>2、如果AVCPacketType=1，则为NALU（一个或多个）<br>3、如果AVCPacketType=2，则为空 |

    - 视频Tag Data开始的第⼀个字节包含视频数据的参数信息，第⼆个字节开始为视频流数据。
    
    - CompositionTime 表示PTS相对于DTS的偏移值， 在每个视频tag的第14-16字节。显示时间(pts) = 解码时间（tag的第5-8字节） + CompositionTime，CompositionTime的单位也是ms。
    
    - FLV分析代码：[FLV分析代码](./analysis/flv/)
